import java.io.*;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import java_cup.runtime.ScannerBuffer;
import java.util.*;
import java_cup.runtime.XMLElement;
import java_cup.runtime.XMLElement.*;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java.nio.file.Paths;

import utils.*;
import analysis.*;
import analysis.models.*;

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at "+cur_token);
    }
    public static void newScope(){
	typenames.push(new HashSet<String>());
    }
    public static void deleteScope(){
	typenames.pop();
    }
    public static boolean lookupType(String name){
	for (HashSet<String> scope: typenames)
	    if (scope.contains(name)) return true;
	return false;
    }
    public static void addType(String name){
	typenames.peek().add(name);
    }
    public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
	    super(lex,sf);
    }

    public static void main(String args[]) {
	try {
	    ComplexSymbolFactory csf = new ComplexSymbolFactory();
	    // create a buffering scanner wrapper
	     String rootPath = Paths.get("").toAbsolutePath().toString();
                String subPath = "/";

                String sourcecode = rootPath + subPath + "input.c";

         System.out.println(sourcecode);

	    ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
	    // start parsing
	    Parser p = new Parser(lexer,csf);
	    System.out.println("Parser runs: ");
	    newScope();
	    p.parse();

	    System.out.println("Parsing finished!");
	} catch (Exception e) {
	    e.printStackTrace();
	}
    }
:};

terminal IDENTIFIER, CONSTANT, STRING_LITERAL, SIZEOF, PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP,
    AND_OP, OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN,
    XOR_ASSIGN, OR_ASSIGN, TYPE_NAME, TYPEDEF, EXTERN, STATIC, AUTO, REGISTER,
    CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, CONST, VOLATILE, VOID, STRUCT, UNION, ENUM, ELLIPSIS,
    CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, GOTO, CONTINUE, BREAK, RETURN,
    SEMI, CURLYL, CURLYR, COMMA, COLON, ASSIGN, PARAL, PARAR, SQUAREDL, SQUAREDR, POINT, ADRESS, NOT, TILDE, MINUS, PLUS, MUL, DIVIDE, MODULUS, LESS, GREATER, XOR, OR, COND;

non terminal translation_unit;
non terminal primary_expression;
non terminal postfix_expression;
non terminal expression;
//non terminal argument_expression_list;
non terminal assignment_expression;
non terminal unary_expression;
non terminal unary_operator;
non terminal type_name;
non terminal  cast_expression;
non terminal  multiplicative_expression;
non terminal  additive_expression;
non terminal  relational_expression;
non terminal  shift_expression;
non terminal  equality_expression;
non terminal  and_expression;
non terminal  exclusive_or_expression;
non terminal  inclusive_or_expression;
non terminal  logical_and_expression;
non terminal  logical_or_expression;
non terminal  conditional_expression;
non terminal  constant_expression;
non terminal  declaration;
non terminal  declaration_specifiers;
non terminal  init_declarator_list;
non terminal  storage_class_specifier;
non terminal  type_specifier;
non terminal  type_qualifier;
non terminal  init_declarator;
non terminal  declarator;
non terminal  struct_or_union_specifier;
non terminal  struct_declaration_list;
//non terminal struct_or_union;
non terminal  struct_declaration;
non terminal  initializer;
non terminal  specifier_qualifier_list;
non terminal  struct_declarator_list;
non terminal  struct_declarator;
non terminal  enum_specifier;
non terminal  enumerator_list;
non terminal  enumerator;
non terminal  pointer;
non terminal  direct_declarator;
non terminal  parameter_type_list;
non terminal  identifier_list;
non terminal  type_qualifier_list;
non terminal  parameter_declaration;
non terminal  abstract_declarator;
non terminal  direct_abstract_declarator;
non terminal  initializer_list;
non terminal  statement;
non terminal  labeled_statement;
non terminal  compound_statement;
non terminal  selection_statement;
non terminal  iteration_statement;
non terminal  jump_statement;
non terminal  statement_list;
non terminal  expression_statement;
non terminal  external_declaration;
non terminal  function_definition;
non terminal  declaration_list;
non terminal  assignment_operator;
non terminal  parameter_list;


precedence nonassoc ELSE;



start with translation_unit;


primary_expression ::= IDENTIFIER:ident {: Logger.getInstance().log("primary_expression 1"); :}
		   | CONSTANT:constant {: Logger.getInstance().log("primary_expression 2"); :}
		   | STRING_LITERAL:stringliteral {: Logger.getInstance().log("primary_expression 3"); :}
		   | PARAL expression:e PARAR {: Logger.getInstance().log("primary_expression 4"); :}
		   ;

postfix_expression ::= primary_expression:pe {: Logger.getInstance().log("postfix_expression 1"); :}
		   | postfix_expression:pe SQUAREDL expression:index SQUAREDR {: Logger.getInstance().log("postfix_expression 2"); :}
		   | postfix_expression:pe PARAL PARAR {: Logger.getInstance().log("postfix_expression 3"); :}
		   | postfix_expression:pe PARAL expression:e PARAR {: Logger.getInstance().log("postfix_expression 4"); :}
		   | postfix_expression:pe POINT IDENTIFIER:id {: Logger.getInstance().log("postfix_expression 5"); :}
		   | postfix_expression:pe PTR_OP IDENTIFIER:id {: Logger.getInstance().log("postfix_expression 6"); :}
		   | postfix_expression:pe INC_OP:op {: Logger.getInstance().log("postfix_expression 7"); :}
		   | postfix_expression:pe DEC_OP:op {: Logger.getInstance().log("postfix_expression 8"); :}
		   ;

unary_expression ::= postfix_expression:pe {: Logger.getInstance().log("unary_expression 1"); :}
		 | INC_OP:op unary_expression:ue {: Logger.getInstance().log("unary_expression 2"); :}
		 | DEC_OP:op unary_expression:ue {: Logger.getInstance().log("unary_expression 3"); :}
		 | unary_operator:uo cast_expression:ce {: Logger.getInstance().log("unary_expression 4"); :}
		 | SIZEOF unary_expression:ue {: Logger.getInstance().log("unary_expression 5"); :}
		 | SIZEOF PARAL type_name:tn PARAR {: Logger.getInstance().log("unary_expression 6"); :}
		 ;

unary_operator
	::=ADRESS {: Logger.getInstance().log("unary_operator 1"); :}
	| MUL:op {: Logger.getInstance().log("unary_operator 2"); :}
	| PLUS:op {: Logger.getInstance().log("unary_operator 3"); :}
	| MINUS:op {: Logger.getInstance().log("unary_operator 4"); :}
	| TILDE {: Logger.getInstance().log("unary_operator 5"); :}
	| NOT:op {: Logger.getInstance().log("unary_operator 6"); :}
	;


cast_expression
	::=unary_expression:ue {: Logger.getInstance().log("cast_expression 1"); :}
	| PARAL type_name:tn PARAR cast_expression:ce {: Logger.getInstance().log("cast_expression 2"); :}
	;


multiplicative_expression ::= cast_expression:ce {: Logger.getInstance().log("multiplicative_expression 1"); :}
			  | multiplicative_expression:me MUL:op cast_expression:ce {: Logger.getInstance().log("multiplicative_expression 2"); :}
			  | multiplicative_expression:me DIVIDE:op cast_expression:ce {: Logger.getInstance().log("multiplicative_expression 3"); :}
			  | multiplicative_expression:me MODULUS:op cast_expression:ce {: Logger.getInstance().log("multiplicative_expression 4"); :}
			  ;

additive_expression ::= multiplicative_expression:me {: Logger.getInstance().log("additive_expression 1"); :}
		    | additive_expression:ae PLUS:op multiplicative_expression:me {: Logger.getInstance().log("additive_expression 2"); :}
		    | additive_expression:ae MINUS:op multiplicative_expression:me {: Logger.getInstance().log("additive_expression 3"); :}
		    ;

shift_expression ::= additive_expression:ae {: Logger.getInstance().log("shift_expression 1"); :}
		 | shift_expression:se LEFT_OP additive_expression:ae {: Logger.getInstance().log("shift_expression 2"); :}
		 | shift_expression:se RIGHT_OP additive_expression:ae {: Logger.getInstance().log("shift_expression 3"); :}
		 ;

relational_expression ::= shift_expression:se {: Logger.getInstance().log("relational_expression 1"); :}
		      | relational_expression:re LESS:op shift_expression:se {: Logger.getInstance().log("relational_expression 2"); :}
		      | relational_expression:re GREATER:op shift_expression:se {: Logger.getInstance().log("relational_expression 3"); :}
		      | relational_expression:re LE_OP:op shift_expression:se {: Logger.getInstance().log("relational_expression 4"); :}
		      | relational_expression:re GE_OP:op shift_expression:se {: Logger.getInstance().log("relational_expression 5"); :}
		      ;

equality_expression ::= relational_expression:re {: Logger.getInstance().log("equality_expression 1"); :}
		    | equality_expression:ee EQ_OP:op relational_expression:re {: Logger.getInstance().log("equality_expression 2"); :}
		    | equality_expression:ee NE_OP:op relational_expression:re {: Logger.getInstance().log("equality_expression 3"); :}
		    ;

and_expression ::= equality_expression:ee {: Logger.getInstance().log("and_expression 1"); :}
	       | and_expression:ae ADRESS equality_expression:ee {: Logger.getInstance().log("and_expression 2"); :}
	       ;

exclusive_or_expression	::= and_expression:ae {: Logger.getInstance().log("exclusive_or_expression 1"); :}
			| exclusive_or_expression:eoe XOR and_expression:ae {: Logger.getInstance().log("exclusive_or_expression 2"); :}
			;


inclusive_or_expression	::= exclusive_or_expression:eoe {: Logger.getInstance().log("inclusive_or_expression 1"); :}
			| inclusive_or_expression:ioe OR exclusive_or_expression:eoe {: Logger.getInstance().log("inclusive_or_expression 2"); :}
			;

logical_and_expression ::= inclusive_or_expression:ioe {: Logger.getInstance().log("logical_and_expression 1"); :}
		       | logical_and_expression:lae AND_OP:op inclusive_or_expression:ioe {: Logger.getInstance().log("logical_and_expression 2"); :}
		       ;

logical_or_expression ::= logical_and_expression:lae {: Logger.getInstance().log("logical_or_expression 1"); :}
		      | logical_or_expression:loe OR_OP:op logical_and_expression:lae {: Logger.getInstance().log("logical_or_expression 2"); :}
		      ;

conditional_expression ::= logical_or_expression:loe {: Logger.getInstance().log("conditional_expression 1"); :}
		       | logical_or_expression:loe COND expression:e COLON conditional_expression:ce {: Logger.getInstance().log("conditional_expression 2"); :}
		       ;


assignment_expression ::= conditional_expression:ce {: Logger.getInstance().log("assignment_expression 1"); :}
		      | unary_expression:ue assignment_operator:aop assignment_expression:ae {: Logger.getInstance().log("assignment_expression 2"); :}
		      ;

assignment_operator
	::=ASSIGN  {: Logger.getInstance().log("assignment_operator 1"); :}
	| MUL_ASSIGN  {: Logger.getInstance().log("assignment_operator 2"); :}
	| DIV_ASSIGN  {: Logger.getInstance().log("assignment_operator 3"); :}
	| MOD_ASSIGN  {: Logger.getInstance().log("assignment_operator 4"); :}
	| ADD_ASSIGN  {: Logger.getInstance().log("assignment_operator 5"); :}
	| SUB_ASSIGN  {: Logger.getInstance().log("assignment_operator 6"); :}
	| LEFT_ASSIGN {: Logger.getInstance().log("assignment_operator 7"); :}
	| RIGHT_ASSIGN {: Logger.getInstance().log("assignment_operator 8"); :}
 	| AND_ASSIGN {: Logger.getInstance().log("assignment_operator 9"); :}
	| XOR_ASSIGN {: Logger.getInstance().log("assignment_operator 10"); :}
	| OR_ASSIGN {: Logger.getInstance().log("assignment_operator 11"); :}
	;

expression ::= assignment_expression:ae {: Logger.getInstance().log("expression 1"); :}
	   | expression:e COMMA assignment_expression:ae {: Logger.getInstance().log("expression 2"); :}
	   ;

constant_expression
	::=conditional_expression:ce {: Logger.getInstance().log("constant_expression 1"); :}
	;

declaration
	::=declaration_specifiers:ds SEMI  {: Logger.getInstance().log("declaration 1"); :}
    | declaration_specifiers:ds init_declarator_list:idl {:
							  if (ds.toString().indexOf(">typedef<")>0) {
							      for (XMLElement e: ((XMLElement)idl).selectById("identifier"))
								Parser.addType(((Terminal)e).value().toString());
							  }
							  Variable v = new Variable((Types) ds, idl.toString());
                              Semantic.getInstance().addVariable(v);
                              RESULT = v;
							  Logger.getInstance().log("declaration 2");
							  :} SEMI
        ;

declaration_specifiers
	::=storage_class_specifier:scc                              {: Logger.getInstance().log("declaration_specifiers 1"); :}
        | storage_class_specifier:scc declaration_specifiers:ds {: Logger.getInstance().log("declaration_specifiers 2"); :}
	| type_specifier:ts                                         {: RESULT = ts; Logger.getInstance().log("declaration_specifiers 3"); :}
	| type_specifier:ts declaration_specifiers:ds               {: Logger.getInstance().log("declaration_specifiers 4"); :}
	| type_qualifier:tq                                         {: Logger.getInstance().log("declaration_specifiers 5"); :}
	| type_qualifier:tq declaration_specifiers:ds               {: Logger.getInstance().log("declaration_specifiers 6"); :}
	;

init_declarator_list
	::=init_declarator:id {: RESULT = id; Logger.getInstance().log("init_declarator_list 1"); :}
	| init_declarator_list:idl COMMA init_declarator:id {: Logger.getInstance().log("init_declarator_list 2"); :}
	;

init_declarator
        ::=declarator:d           {: RESULT = d; Logger.getInstance().log("init_declarator 1"); :}
	| declarator:d ASSIGN initializer:i  {: RESULT = d; Logger.getInstance().log("init_declarator 2"); :}
	;

storage_class_specifier
    ::=  TYPEDEF:id {: Logger.getInstance().log("storage_class_specifier 1"); :}
	| EXTERN:id     {: Logger.getInstance().log("storage_class_specifier 2"); :}
	| STATIC:id     {: Logger.getInstance().log("storage_class_specifier 3"); :}
	| AUTO:id       {: Logger.getInstance().log("storage_class_specifier 4"); :}
	| REGISTER:id   {: Logger.getInstance().log("storage_class_specifier 5"); :}
	;

type_specifier
	::=VOID:type                      {: RESULT = Types.VOID; Logger.getInstance().log("type_specifier 1"); :}
	| CHAR:type                       {: RESULT = Types.STRING; Logger.getInstance().log("type_specifier 2"); :}
	| SHORT:type                      {: RESULT = Types.INT; Logger.getInstance().log("type_specifier 3"); :}
	| INT:type                        {: RESULT = Types.INT; Logger.getInstance().log("type_specifier 4"); :}
	| LONG:type                       {: Logger.getInstance().log("type_specifier 5"); :}
	| FLOAT:type                      {: RESULT = Types.FLOAT; Logger.getInstance().log("type_specifier 6"); :}
	| DOUBLE:type                     {: RESULT = Types.FLOAT; Logger.getInstance().log("type_specifier 7"); :}
	| SIGNED:type                     {: RESULT = Types.INT; Logger.getInstance().log("type_specifier 8"); :}
	| UNSIGNED:type                   {: RESULT = Types.INT; Logger.getInstance().log("type_specifier 9"); :}
	| struct_or_union_specifier:su    {: Logger.getInstance().log("type_specifier 10"); :}
	| enum_specifier:es               {: Logger.getInstance().log("type_specifier 11"); :}
	| TYPE_NAME:type                  {: Logger.getInstance().log("type_specifier 12"); :}
	;

struct_or_union_specifier
	::= STRUCT:s IDENTIFIER:id CURLYL struct_declaration_list:sdl CURLYR  {: Logger.getInstance().log("struct_or_union_specifier 1"); :}
	|  STRUCT:s CURLYL struct_declaration_list:sdl CURLYR                 {: Logger.getInstance().log("struct_or_union_specifier 2"); :}
	|  STRUCT:s IDENTIFIER:id                                             {: Logger.getInstance().log("struct_or_union_specifier 3"); :}
	|  UNION:u IDENTIFIER:id CURLYL struct_declaration_list:sdl CURLYR    {: Logger.getInstance().log("struct_or_union_specifier 4"); :}
	|  UNION:u CURLYL struct_declaration_list:sdl CURLYR                  {: Logger.getInstance().log("struct_or_union_specifier 5"); :}
	|  UNION:u IDENTIFIER:id                                              {: Logger.getInstance().log("struct_or_union_specifier 6"); :}
	;

struct_declaration_list
	::=struct_declaration:s      {: Logger.getInstance().log("struct_declaration_list 1"); :}
	| struct_declaration_list:sl struct_declaration:s   {: Logger.getInstance().log("struct_declaration_list 2"); :}
	;

struct_declaration
	::=specifier_qualifier_list:sq struct_declarator_list:sd SEMI {: Logger.getInstance().log("struct_declaration 1"); :}
	;

specifier_qualifier_list
	::=type_specifier:ts specifier_qualifier_list:sq  {: Logger.getInstance().log("specifier_qualifier_list 1"); :}
	| type_specifier:ts                               {: Logger.getInstance().log("specifier_qualifier_list 2"); :}
	| type_qualifier:tq specifier_qualifier_list:sq   {: Logger.getInstance().log("specifier_qualifier_list 3"); :}
	| type_qualifier:tq                               {: Logger.getInstance().log("specifier_qualifier_list 4"); :}
	;

struct_declarator_list
	::=struct_declarator:s      {: Logger.getInstance().log("struct_declarator_list 1"); :}
	| struct_declarator_list:sl COMMA struct_declarator:s  {: Logger.getInstance().log("struct_declarator_list 2"); :}
	;

struct_declarator
	::=declarator:d                               {: Logger.getInstance().log("struct_declarator 1"); :}
	| COLON constant_expression:ce                {: Logger.getInstance().log("struct_declarator 2"); :}
	| declarator:d COLON constant_expression:ce   {: Logger.getInstance().log("struct_declarator 3"); :}
	;

enum_specifier
	::=ENUM CURLYL enumerator_list:el CURLYR                {: Logger.getInstance().log("enum_specifier 1"); :}
	| ENUM IDENTIFIER:id CURLYL enumerator_list:el CURLYR   {: Logger.getInstance().log("enum_specifier 2"); :}
	| ENUM IDENTIFIER:id                                    {: Logger.getInstance().log("enum_specifier 3"); :}
	;

enumerator_list
	::=enumerator:e                          {: Logger.getInstance().log("enumerator_list 1"); :}
	| enumerator_list:el COMMA enumerator:e  {: Logger.getInstance().log("enumerator_list 2"); :}
	;

enumerator
	::=IDENTIFIER:id                                {: Logger.getInstance().log("enumerator 1"); :}
	| IDENTIFIER:id ASSIGN constant_expression:ce   {: Logger.getInstance().log("enumerator 2"); :}
	;

type_qualifier
	::=CONST:id      {: Logger.getInstance().log("type_qualifier 1"); :}
	| VOLATILE:id    {: Logger.getInstance().log("type_qualifier 2"); :}
	;

declarator
	::=pointer:p direct_declarator:direct  {: Logger.getInstance().log("declarator 1"); :}
	| direct_declarator:direct             {: RESULT = direct; Logger.getInstance().log("declarator 2"); :}
	;

direct_declarator
	::=IDENTIFIER:identifier             {: RESULT = identifier; Logger.getInstance().log("direct_declarator 1"); :}
	| PARAL declarator:d PARAR           {: Logger.getInstance().log("direct_declarator 2"); :}
	| direct_declarator:dd SQUAREDL constant_expression:ce SQUAREDR {: Logger.getInstance().log("direct_declarator 3"); :}
	| direct_declarator:dd SQUAREDL SQUAREDR                        {: Logger.getInstance().log("direct_declarator 4"); :}
	| direct_declarator:dd PARAL parameter_type_list:ptl PARAR      {: Logger.getInstance().log("direct_declarator 5"); :}
	| direct_declarator:dd PARAL identifier_list:il PARAR           {: Logger.getInstance().log("direct_declarator 6"); :}
	| direct_declarator:dd PARAL PARAR                              {: Logger.getInstance().log("direct_declarator 7"); :}
	;

pointer
	::=MUL:id                                   {: Logger.getInstance().log("pointer 1"); :}
	| MUL:id type_qualifier_list:tql            {: Logger.getInstance().log("pointer 2"); :}
	| MUL:id pointer:p                          {: Logger.getInstance().log("pointer 3"); :}
	| MUL:id type_qualifier_list:tql pointer:p  {: Logger.getInstance().log("pointer 4"); :}
	;

type_qualifier_list
	::=type_qualifier:tq                         {: Logger.getInstance().log("type_qualifier_list 1"); :}
	| type_qualifier_list:tql type_qualifier:tq  {: Logger.getInstance().log("type_qualifier_list 2"); :}
	;


parameter_type_list
	::=parameter_list:pl                    {: Logger.getInstance().log("parameter_type_list 1"); :}
	| parameter_list:pl COMMA ELLIPSIS:id   {: Logger.getInstance().log("parameter_type_list 2"); :}
	;

parameter_list
	::=parameter_declaration:pd                          {: Logger.getInstance().log("parameter_list 1"); :}
	| parameter_list:pl COMMA parameter_declaration:pd   {: Logger.getInstance().log("parameter_list 2"); :}
	;

parameter_declaration
	::=declaration_specifiers:ds declarator:d           {: Logger.getInstance().log("parameter_declaration 1"); :}
	| declaration_specifiers:ds abstract_declarator:ad  {: Logger.getInstance().log("parameter_declaration 2"); :}
	| declaration_specifiers:ds                         {: Logger.getInstance().log("parameter_declaration 3 "); :}
	;

identifier_list
	::=IDENTIFIER:id                           {: Logger.getInstance().log("identifier_list 1"); :}
	| identifier_list:idl COMMA IDENTIFIER:id  {: Logger.getInstance().log("identifier_list 2"); :}
	;

type_name
	::=specifier_qualifier_list:sl                        {: Logger.getInstance().log("type_name 1"); :}
	| specifier_qualifier_list:sl abstract_declarator:ad  {: Logger.getInstance().log("type_name 2"); :}
	;

abstract_declarator
	::=pointer:p                               {: Logger.getInstance().log("abstract_declarator 1"); :}
	| direct_abstract_declarator:dad           {: Logger.getInstance().log("abstract_declarator 2"); :}
	| pointer:p direct_abstract_declarator:d   {: Logger.getInstance().log("abstract_declarator 3"); :}
	;

direct_abstract_declarator
	::=PARAL:id abstract_declarator:ad PARAR                                      {: Logger.getInstance().log("direct_abstract_declarator 1"); :}
	| SQUAREDL:id SQUAREDR                                                        {: Logger.getInstance().log("direct_abstract_declarator 2"); :}
	| SQUAREDL:id constant_expression:ce SQUAREDR                                 {: Logger.getInstance().log("direct_abstract_declarator 3"); :}
	| direct_abstract_declarator:dad SQUAREDL:id SQUAREDR                         {: Logger.getInstance().log("direct_abstract_declarator 4"); :}
	| direct_abstract_declarator:dad SQUAREDL:id constant_expression:ce SQUAREDR  {: Logger.getInstance().log("direct_abstract_declarator 5"); :}
	| PARAL:id PARAR                                                              {: Logger.getInstance().log("direct_abstract_declarator 6"); :}
	| PARAL:id parameter_type_list:ptl PARAR                                      {: Logger.getInstance().log("direct_abstract_declarator 7"); :}
	| direct_abstract_declarator:dad PARAL:id PARAR                               {: Logger.getInstance().log("direct_abstract_declarator 8"); :}
	| direct_abstract_declarator:dad PARAL:id parameter_type_list:ptl PARAR       {: Logger.getInstance().log("direct_abstract_declarator 9"); :}
	;

initializer
	::=assignment_expression:ae                 {: Logger.getInstance().log("initializer 1"); :}
	| CURLYL initializer_list:il CURLYR         {: Logger.getInstance().log("initializer 2"); :}
	| CURLYL initializer_list:il COMMA CURLYR   {: Logger.getInstance().log("initializer 3"); :}
	;

initializer_list
	::=initializer:i                            {: Logger.getInstance().log("initializer_list 1"); :}
	| initializer_list:il COMMA initializer:i   {: Logger.getInstance().log("initializer_list 2"); :}
	;

statement
	::=labeled_statement:ls {: Logger.getInstance().log("statement 1"); :}
	| {: Parser.newScope(); :}  compound_statement:cs {: Parser.deleteScope(); Logger.getInstance().log("statement 2"); :}
	| expression_statement:es {: Logger.getInstance().log("statement 3"); :}
	| selection_statement:ss {: Logger.getInstance().log("statement 4"); :}
	| iteration_statement:is {: Logger.getInstance().log("statement 5"); :}
	| jump_statement:js {: Logger.getInstance().log("statement 6"); :}
	;

labeled_statement
	::=IDENTIFIER:id COLON statement:s                {: Logger.getInstance().log("labeled_statement 1"); :}
	| CASE constant_expression:ce COLON statement:s   {: Logger.getInstance().log("labeled_statement 2"); :}
	| DEFAULT COLON statement:s                       {: Logger.getInstance().log("labeled_statement 3"); :}
	;

compound_statement
	::=CURLYL CURLYR                                        {: Logger.getInstance().log("compound_statement 1"); :}
        | CURLYL statement_list:sl CURLYR                   {: Logger.getInstance().log("compound_statement 2"); :}
	| CURLYL declaration_list:dl CURLYR                     {: Logger.getInstance().log("compound_statement 3"); :}
	| CURLYL declaration_list:dl statement_list:sl CURLYR   {: Logger.getInstance().log("compound_statement 4"); :}
	;

declaration_list
	::=declaration:d                       {: Logger.getInstance().log("declaration_list 1"); :}
	| declaration_list:dl declaration:d    {: Logger.getInstance().log("declaration_list 2"); :}
	;

statement_list
	::=statement:s                    {: Logger.getInstance().log("statement_list 1"); :}
	| statement_list:sl statement:s   {: Logger.getInstance().log("statement_list 2"); :}
	;

expression_statement
	::=SEMI {: Logger.getInstance().log("expression_statement 1"); :}
	| expression:e SEMI {: Logger.getInstance().log("expression_statement 2"); :}
	;

selection_statement
	::=IF PARAL expression:e PARAR statement:s                    {: Logger.getInstance().log("selection_statement 1"); :}
	| IF PARAL expression:e PARAR statement:s1 ELSE statement:s2  {: Logger.getInstance().log("selection_statement 2"); :}
	| SWITCH PARAL expression:e PARAR statement:s                 {: Logger.getInstance().log("selection_statement 3"); :}
	;

iteration_statement
	::=WHILE PARAL expression:e PARAR statement:s {: Logger.getInstance().log("iteration_statement 1"); :}
	| DO statement:s WHILE PARAL expression:e PARAR SEMI {: Logger.getInstance().log("iteration_statement 2"); :}
	| FOR PARAL expression_statement:es1 expression_statement:es2 PARAR statement:s {: Logger.getInstance().log("iteration_statement 3"); :}
	| FOR PARAL expression_statement:es1 expression_statement:es2 expression:e PARAR statement:s {: Logger.getInstance().log("iteration_statement 4"); :}
	;

jump_statement
	::=GOTO IDENTIFIER:id SEMI  {: Logger.getInstance().log("jump_statement 1"); :}
	| CONTINUE SEMI             {: Logger.getInstance().log("jump_statement 2"); :}
	| BREAK SEMI                {: Logger.getInstance().log("jump_statement 3"); :}
	| RETURN SEMI               {: Logger.getInstance().log("jump_statement 4"); :}
	| RETURN expression:e SEMI  {: Logger.getInstance().log("jump_statement 5"); :}
	;

translation_unit
	::=external_declaration:ed                      {: Logger.getInstance().log("translation_unit 1"); :}
	| translation_unit:tu external_declaration:ed   {: Logger.getInstance().log("translation_unit 2"); :}
	;

external_declaration
	::=function_definition:fd   {: Logger.getInstance().log("external_declaration 1"); :}
	| declaration:d             {: Logger.getInstance().log("external_declaration 2"); :}
	;

function_definition
	::=declaration_specifiers:ds declarator:d declaration_list:dl {: Parser.newScope(); :} compound_statement:cs {: Parser.deleteScope();  Logger.getInstance().log("function_definition 1");:}
	| declaration_specifiers:ds declarator:d {: Parser.newScope(); :}  compound_statement:cs {: Parser.deleteScope(); Logger.getInstance().log("function_definition 2");:}
	| declarator:d declaration_list:dl {: Parser.newScope(); :} compound_statement:cs {: Parser.deleteScope(); Logger.getInstance().log("function_definition 3");:}
	| declarator:d {: Parser.newScope(); :}  compound_statement:cs {: Parser.deleteScope(); Logger.getInstance().log("function_definition 4");:}
	;
